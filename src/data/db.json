{
  "posts": [
    {
      "createdAt": 1621139532415,
      "title": "Reactを使ったテックブログを作成してみた",
      "body": "## はじめに\n\nReactを学習していくにあたり、REST APIを用いたCRUD操作の勉強のため技術ブログを作成してみました。\n\nhttps://github.com/himorishige/techBlog\n\n今回は簡易的に利用できるJSON Serverを使ってデータのやり取りを行い、Redux Toolkitを追加状態の管理を行っています。\n今後は外部サイトに公開できるように外部のデータベースと連携していきたいところです。\n\n## 仕様について\n\n今回は下記のような仕様を想定して制作を行いました。\n\n- 閲覧ユーザー向けの機能\n  - 記事一覧を表示する（公開設定している記事のみ）\n  - 記事詳細を表示する\n  - いいねボタンを押すといいねが1増える（何度も押せる）\n- 管理ユーザー向けの機能\n  - 登録記事一覧を表示する\n  - 記事詳細を表示する\n  - 記事の編集ができる\n  - 記事の公開・非公開の切り替えができる\n  - 記事の削除ができる\n  - 新規記事の作成ができる\n  - 記事はマークダウン記法で登録できる\n  - ログイン機能はなし\n  - 画像の投稿機能はなし\n\n## 主な利用サービス・利用技術\n\n- React\n- Redux Toolkit\n- JSON Server … JSONファイルをデータベースとして利用できる簡易APIサーバー\n- react-markdown … Reactで使えるマークダウン変換ライブラリ\n- styled-components\n- TypeScript\n\n## JSON Server\n\n今回外部APIとしてJSON Serverを利用しました。\nデータベースとしてJSONファイルをそのまま利用することができるので、余計な手間をかけずにすぐに開発に取り掛かることができます。JSON形式のデータを返すAPIであれば、JSON Serverで作成後にURLだけ変えれば外部との連携に簡単に切り替えることもできます。\n\n### セットアップ\n\n```bash\n$ yarn add json-server\n```\n\nデータベースとして利用するJSONファイルを用意します。\nフォーマットとしてはリソース名を1階層目に必ず用意しなくてはいけません。\n今回はブログサイトを想定していますので下記のようなダミーデータを用意しました。\n\n```json:src/data/db.json\n{\n  \"posts\": [\n    {\n      \"id\": \"1\",\n      \"title\": \"create-react-app直後にやる環境構築の備忘録\",\n      \"createdAt\": 1620804168398,\n      \"updatedAt\": 1621064460898,\n      \"body\": \"本文テキスト1\",\n      \"image\": \"/assets/images/dummy01.jpeg\",\n      \"like\": 100,\n      \"publish\": false\n    },\n    {\n      \"id\": \"2\",\n      \"title\": \"Reactを使ったお天気アプリを作成してみた\",\n      \"createdAt\": 1620804168398,\n      \"updatedAt\": 1621070951011,\n      \"body\": \"本文テキスト2\",\n      \"image\": \"/assets/images/dummy01.jpeg\",\n      \"like\": 112,\n      \"publish\": true\n    }\n  ]\n}\n```\n\nReact内で扱う型としては下記を想定しています。\n投稿「Post」とその一覧「Post[]」という形です。\n\n```typescript:src/types/index.ts\nexport type Post = {\n  id: string;\n  createdAt: number;\n  updatedAt?: number;\n  title: string;\n  body: string;\n  image: string;\n  like: number;\n  publish: boolean;\n};\n\nexport type Posts = Post[];\n```\n\npackage.jsonにJSON Server起動用のスクリプトを追記します。\n\n```json:package.json\n  \"scripts\": {\n    \"json-server\": \"json-server --watch src/data/db.json -p 3001 -d 2000\"\n  },\n```\n\n**--watch**をつけることで常時監視モードで起動することができます。\nReactがポート3000を利用するため、**-p 3001**として3001番ポートで起動するように変更。\nまた、**-d 2000**として2秒の待ち時間を入れるようにしています。待ち時間を入れることで非同期のテストも体感的にわかりやすくなのでとても便利です。\n\n```bash\n$ yarn json-server\n```\n\nブラウザで **http://localhost:3001/posts** を開くと登録した記事一覧を表示することができます。\n\n## JSON ServerへのCRUD操作\n\n今回は記事の登録、編集、削除に合わせてRedux ToolkitのcreateAsyncThunk、axiosを利用してJSON Serverへアクセスしました。\n\n```typescript\nconst post:Post = 記事データ\n\n// 登録 POST\nconst response = await axios\n  .post<Post>(`${URL}/posts`, post)\n  .catch((err) => {\n    // エラー処理\n  });\nreturn response.data;\n\n// 編集 PUT\nconst response = await axios\n  .put<Post>(`${URL}/posts/${post.id}`, post)\n  .catch((err) => {\n    // エラー処理\n  });\nreturn response.data;\n\n// 削除 DELETE\nconst response = await axios\n  .delete<Post>(`${URL}/posts/${post.id}`, {\n    data: { id: post.id },\n  })\n  .catch((err) => {\n    // エラー処理\n  });\nreturn response.data;\n```\n\n上記は省略していますが前後の処理については下記ソースを参照いただければと思います。\n\nhttps://github.com/himorishige/techBlog/blob/main/src/features/posts/postsEntitySlice.ts\n\n## Redux Toolkit\n\nJSON Serverからデータの取得にはcreateAsyncThunkを経由して、createEntityAdapterを使い処理を行っています。\n詳細は下記にも記事を投稿させていただきました。\n\nqiita記事リンク\n\n## 苦労した点\n\nReact Routerで複数のページを扱いながら、その中でできる限りムダな通信や処理は行わないように考えることに時間をかなり要してしまいました。ただ今回は制限などがある外部のAPIではなくローカル環境で構築ができたので制限にびくびくする必要なく精神衛生上よかったように思います。\nまた非同期の処理については相変わらず怪しい知識のままなのですが、今回はRedux ToolkitのcreateAsyncThunkを利用することで比較的簡単に処理を分岐できたのが大きな発見でした。\n\n## 今後の拡張\n\n今後の拡張としては今の所下記を想定したいところです。。。\n\n- 管理画面の認証機能\n- 画像の投稿機能\n- Express、mongoDBを用いたバックエンド構築\n\n# さいごに\n\nチュートリアル的なTODOアプリからちょっと進んだ？、APIを用いたCRUDなアプリケーションを作成することでより知識を深めることができました。JSON Serverで気軽にバックエンドを構築できてたのもあり、制作期間も1週間程度とかなり短期間ですすめることができたのも大きな一歩です。\nテックブログもすこしずつ拡張しながらさらに知識を深めていこうと思います。\n\n# 関連記事\n\nReduxの記事\n\n# 参考サイト\n\nReact\n\nhttps://github.com/reduxjs/cra-template-redux-typescript\n\nJSON Server\n\nhttps://github.com/typicode/json-server\n\nhttps://www.codegrid.net/articles/2017-json-server-1/\n\nRedux\n\nhttps://www.youtube.com/watch?v=Lmtr8hmXvj4&list=PLtbitg0evatjxN_BhyJO124bV2eDoJumf\n\nhttps://www.youtube.com/watch?v=yQz2gSQiOZA&list=PLtbitg0evatg24WZm9Q8wTIP-We2V0OpZ\n\nhttps://www.cyokodog.net/blog/redux-toolkit-async-thunk/\n\nhttps://redux-toolkit.js.org/api/createAsyncThunk\n\nhttps://redux-toolkit.js.org/api/createEntityAdapter\n\n",
      "image": "/assets/images/dummy01.jpeg",
      "like": 0,
      "publish": true,
      "id": 1
    },
    {
      "id": 2,
      "title": "ReduxとRedux Toolkitについて[createAsyncThunkとcreateEntityAdapter推し]",
      "createdAt": 1621142384990,
      "updatedAt": 1621142670798,
      "body": "## はじめに\n\nReact初学者がReduxとRedux Toolkitについて調べてみた備忘録です。\n学び始めたときにはすでにToolkitが1.4まで進んでいたので最初から利用させていただいてますが、個人的にはcreateAsyncThunkとcreateEntityAdapter推しです😅\n誤り等ありましたらやさしくご指摘だけると幸いです🙇🏻‍♂️\n\n## Reduxとは\n\nReduxは、「Action」と呼ばれるイベントを用いて、アプリケーションの状態（state）を管理・更新するためのライブラリです。React以外にも利用されていますがReactとともに用いられることが多いようです。\nFluxというデータフローの概念を利用して設計されており、主にAction、Store、Reducerの要素で構成されています。\n\nReactでは各コンポーネントがpropとstateを持っていますが、アプリケーションの規模が大きくなりにつれ、コンポーネント間のやり取りが大変になってきます。俗にprop drilling problemとも呼ばれています。\nReduxを用いるとStoreという唯一の箱のようなものでstateを管理するため、どこからでも更新、参照できるという大きなメリットを持っています。\n\nReduxの大まかな流れとしては、\n\n- ActionはActionCreatorで作られます。\n- Storeではstateを管理しています。\n- ReducerはActionとstateから新しいstateを作成します。\n\nまず、ユーザーは行いたいActionを、Storeに対してdispatchというメソッドを用いて送信します。\n次にReducerが、Storeが受け取ったActionにしたがってstateから新しいstateを作成して返します。\n必ず新しいstateのみを返すことで、Reduxではアプリケーションの中で状態がいつ、どのように更新されたかを容易に把握することができるようになっています。\n\n![スクリーンショット_2021-05-15_20_39_49.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/1268181/eb89b27b-0106-ca06-77f0-1945a73e449a.png)\n\nタイムトラベルデバッギングとも言われているようで、デベロッパーツールを用いると時間軸に沿った動きをデバッグすることができます。\n\nツールとしてはとても有益な反面、ルールが厳格で手続き上記載する内容も冗長になることで学習コスト、運用コストもかかるため最近では脱Redux論もさかんに議論されているようです。\n\n## Redux Toolkit\n\nそんな中公式のRedux Toolkitが2019/10にリリースされました。  \nRedux ToolkitはReduxをより簡潔に記述するためのツールです。公式ページに掲載されているRedux Style GuideでもToolkitの利用を推奨しています。\n\nhttps://redux.js.org/style-guide/style-guide\n\n## Redux Toolkitを使うメリット\n\n### 初期設定などがほとんど不要になる\n\nRedux DevTools Extension（デバッギングツール）の設定や非同期通信を扱うReduxThunkなどのミドルウェアが同梱されているため、設定不要で利用することができます。\n\n### コード量（ファイル数？）が少なくなる\n\nAction、ActionCreator、ReducerがcreateSliceというひとつの記述でまとめて記載することができます。\n一つのファイルのコード行数は増えるかも。。\n\n### stateのイミュータブルを意識なくてよい\n\nReducerの中で新しいstateを返す際には必ずイミュータブルな値となるようにしなければなりませんでしたが、Toolkitでは内部で自動的にイミュータブルな値として処理を行ってくれます。\n\n### TypeScriptの型が効く\n\nToolkitでは多くの型が設定されいるので型による補完と制御の恩恵を受けることができます。\ncreate-react-appのReduxテンプレートを使うとそのまま利用できる部分も多くとても便利です。\n\nhttps://github.com/reduxjs/cra-template-redux\n\n### createAsyncThunkとcreateEntityAdapterが便利\n\nToolkitの1.3から追加されたcreateAsyncThunkとcreateEntityAdapterがとても便利です。\n\n### createAsyncThunk\n\nhttps://redux-toolkit.js.org/api/createAsyncThunk\n\n非同期処理に対応したActionCreatorを生成する関数で、下記3種の状態を簡単に管理することができます。\n\n- pending: 非同期処理中\n- fulfilled: 非同期処理の成功時\n- rejected: 非同期処理の失敗時\n\n### createEntityAdapter\n\nhttps://redux-toolkit.js.org/api/createEntityAdapter\n\n型情報をもとにエンティティ操作用のAdapterを生成し、CRUD（create, read, update, delete）操作の機能を提供してくれる関数です。\nデータベースを扱うような形で処理を行うことができるようになります。\n\n```typescript\n{\n  id: 1,\n  title: 'create-react-app直後にやる環境構築の備忘録',\n  createdAt: 1620804168398,\n  updatedAt: 1621064460898,\n  body: '本文テキスト',\n  image: '/assets/images/dummy01.jpeg',\n  like: 167,\n  publish: false\n} \n```\n\n例えば上記のような形式を下記のような形に自動的に変換して管理してくれます。\n\n```typescript\n{\n  postsEntity: {\n    ids: [\n      1,\n      2\n    ],\n    entities: {\n      '1': {\n        id: 1,\n        title: 'create-react-app直後にやる環境構築の備忘録',\n        createdAt: 1620804168398,\n        updatedAt: 1621064460898,\n        body: '本文テキスト',\n        image: '/assets/images/dummy01.jpeg',\n        like: 167,\n        publish: false\n      },\n      '2': {\n        id: 2,\n        title: 'Reactを使ったお天気アプリを作成してみた',\n        createdAt: 1620804168398,\n        updatedAt: 1621070951011,\n        body: '本文テキスト2',\n        image: '/assets/images/dummy01.jpeg',\n        like: 112,\n        publish: true\n      },\n    },\n  }\n}\n```\n\nデータのエンティティ化（ノーマライズ）についてのは下記でサンプルをベースに解説されています。\n\nhttps://redux.js.org/recipes/structuring-reducers/normalizing-state-shape\n\n### 実装例 \n\n少々長いのですが実装を行ったサンプルになります。\nまずはベースとなる型情報。ブログの投稿をイメージしています。\n\n```typescript:src/types/index.ts\nexport type Post = {\n  id: string;\n  createdAt: number;\n  updatedAt?: number;\n  title: string;\n  body: string;\n  image: string;\n  like: number;\n  publish: boolean;\n};\n\nexport type Posts = Post[];\n```\n\n以下投稿一覧の取得や更新、削除を行うSliceのサンプルです。\n\nqiitaのリンク\n\nこちらで作成したテックブログのソースコードになっています。\ncreateEntityAdapterで作成したAdapterに対しては下記のメソッドが利用できます。\n\n- addOne 1件追加\n- addMany 複数追加\n- setAll 全件追加上書き\n- removeOne 1件削除\n- removeMany 複数削除\n- removeAll 全件削除\n- updateOne 1件を更新\n- updateMany 複数更新\n- upsertOne 1件を更新、存在しない場合は追加\n- upsertMany 複数を更新、存在しない場合は追加\n\nが利用できます。\n\n```typescript:src/features/posts/postsEntitySlice.ts\nimport {\n  createAsyncThunk,\n  createEntityAdapter,\n  createSlice,\n  PayloadAction,\n} from '@reduxjs/toolkit';\nimport { RootState } from 'src/app/store';\nimport axios from 'axios';\n\nimport { Post, Posts } from 'src/types';\n\nexport type PostsState = {\n  posts: Posts;\n  status: 'idle' | 'loading' | 'failed';\n  message: string;\n};\n\n/**\n * entity用のアダプターを生成\n */\n\n\nconst postsAdapter = createEntityAdapter<Post>({\n  // 記事のデフォルトの並び順を降順に変更\n  selectId: (post) => post.id,\n  sortComparer: (a, b) => {\n    if (a.id < b.id) {\n      return 1;\n    } else {\n      return -1;\n    }\n  },\n});\n\nconst postInitialEntityState = postsAdapter.getInitialState({\n  // 型以外に設定したいものはここで用意\n  status: 'idle',\n  message: '',\n});\n\n// APIのエンドポイント\nconst URL = process.env.REACT_APP_JSON_SERVER_URL || 'http://localhost:3000';\n\n/**\n * 投稿一覧を取得する\n */\n\nexport const fetchEntityPosts = createAsyncThunk('posts/fetchEntityPosts', async (_, thunkApi) => {\n  const response = await axios.get<Posts>(`${URL}/posts`).catch((err) => {\n    thunkApi.rejectWithValue(err); // thunkApiを利用してエラーメッセージなどをreducerにわたすことができる\n    throw err;\n  });\n  return response.data;\n});\n\n/**\n * 投稿を追加する\n */\n\nexport const addEntityPost = createAsyncThunk(\n  'posts/addEntityPost',\n  async (post: Omit<Post, 'id'>, thunkApi) => {\n    const response = await axios.post<Post>(`${URL}/posts`, post).catch((err) => {\n      thunkApi.rejectWithValue(err);\n      throw err;\n    });\n    return response.data;\n  },\n);\n\n/**\n * 投稿を編集する\n */\n\nexport const updateEntityPost = createAsyncThunk(\n  'posts/updateEntityPost',\n  async (post: Post, thunkApi) => {\n    const response = await axios.put<Post>(`${URL}/posts/${post.id}`, post).catch((err) => {\n      thunkApi.rejectWithValue(err);\n      throw err;\n    });\n    return response.data;\n  },\n);\n\n/**\n * 投稿を削除する\n */\n\nexport const deleteEntityPost = createAsyncThunk(\n  'posts/deleteEntityPost',\n  async (postId: string, thunkApi) => {\n    const response = await axios\n      .delete<Post>(`${URL}/posts/${postId}`, {\n        data: { id: postId },\n      })\n      .catch((err) => {\n        thunkApi.rejectWithValue(err);\n        throw err;\n      });\n    return { data: response.data, postId };\n  },\n);\n\n/**\n * 該当する投稿IDにいいねを1プラスする\n */\n\nexport const putLikes = createAsyncThunk('posts/putLikes', async (postData: Post, thunkApi) => {\n  const response = await axios\n    .put<Post>(`${URL}/posts/${postData.id}`, {\n      ...postData,\n      like: postData.like + 1,\n    })\n    .catch((err) => {\n      thunkApi.rejectWithValue(err);\n      throw err;\n    });\n\n  return { id: response.data.id, like: response.data.like };\n});\n\n/**\n * 公開・非公開を切り替える\n */\n\nexport const togglePublish = createAsyncThunk(\n  'posts/togglePublish',\n  async (postData: Post, thunkApi) => {\n    const response = await axios\n      .put<Post>(`${URL}/posts/${postData.id}`, {\n        ...postData,\n        publish: !postData.publish,\n      })\n      .catch((err) => {\n        thunkApi.rejectWithValue(err);\n        throw err;\n      });\n    return { id: response.data.id, publish: response.data.publish };\n  },\n);\n\nexport const postsEntitySlice = createSlice({\n  name: 'postsEntity',\n  initialState: postInitialEntityState,\n  reducers: {},\n  extraReducers: (builder) => {\n    builder\n      .addCase(fetchEntityPosts.pending, (state) => {\n        // ローディング中\n        state.status = 'loading';\n        state.message = '';\n      })\n      .addCase(fetchEntityPosts.rejected, (state, action) => {\n        // 失敗\n        state.status = 'failed';\n        if (action.error.message) {\n          state.message = action.error.message;\n        }\n      })\n      .addCase(fetchEntityPosts.fulfilled, (state, action) => {\n        // 成功\n        state.status = 'idle';\n        // 取得した投稿全件をstoreに登録\n        postsAdapter.setAll(state, action.payload);\n      })\n      .addCase(addEntityPost.pending, (state) => {\n        state.status = 'loading';\n        state.message = '';\n      })\n      .addCase(addEntityPost.rejected, (state, action) => {\n        state.status = 'failed';\n        if (action.error.message) {\n          state.message = action.error.message;\n        }\n      })\n      .addCase(addEntityPost.fulfilled, (state, action) => {\n        state.status = 'idle';\n        // 1件をstoreに新規登録\n        postsAdapter.addOne(state, action.payload);\n      })\n      .addCase(updateEntityPost.pending, (state) => {\n        state.message = '';\n      })\n      .addCase(updateEntityPost.rejected, (state, action) => {\n        if (action.error.message) {\n          state.message = action.error.message;\n        }\n      })\n      .addCase(updateEntityPost.fulfilled, (state, action: PayloadAction<Post>) => {\n        state.status = 'idle';\n        const { id, ...updateData } = action.payload;\n        // 1件をidで指定して更新\n        postsAdapter.updateOne(state, {\n          id: id,\n          changes: { ...updateData },\n        });\n      })\n      .addCase(deleteEntityPost.pending, (state) => {\n        state.status = 'loading';\n        state.message = '';\n      })\n      .addCase(deleteEntityPost.rejected, (state, action) => {\n        state.status = 'failed';\n        if (action.error.message) {\n          state.message = action.error.message;\n        }\n      })\n      .addCase(deleteEntityPost.fulfilled, (state, action) => {\n        state.status = 'idle';\n        postsAdapter.removeOne(state, action.payload.postId);\n      })\n      .addCase(putLikes.pending, (state) => {\n        state.message = '';\n      })\n      .addCase(putLikes.rejected, (state, action) => {\n        if (action.error.message) {\n          state.message = action.error.message;\n        }\n      })\n      .addCase(putLikes.fulfilled, (state, action: PayloadAction<{ id: string; like: number }>) => {\n        state.status = 'idle';\n        // 1件のlikeという項目のみ更新\n        postsAdapter.updateOne(state, {\n          id: action.payload.id,\n          changes: { like: action.payload.like },\n        });\n      })\n      .addCase(togglePublish.pending, (state) => {\n        state.message = '';\n      })\n      .addCase(togglePublish.rejected, (state, action) => {\n        if (action.error.message) {\n          state.message = action.error.message;\n        }\n      })\n      .addCase(\n        togglePublish.fulfilled,\n        (state, action: PayloadAction<{ id: string; publish: boolean }>) => {\n          // 1件のpublishという項目のみ更新\n          state.status = 'idle';\n          postsAdapter.updateOne(state, {\n            id: action.payload.id,\n            changes: { publish: action.payload.publish },\n          });\n        },\n      );\n  },\n});\n\nexport default postsEntitySlice.reducer;\n\n// 全件取得用のselector\nexport const selectPosts = postsAdapter.getSelectors<RootState>((state) => state.postsEntity);\n\n// 単一項目取得用のselector\nexport const selectStatus = (state: RootState) => state.postsEntity.status;\nexport const selectMessage = (state: RootState) => state.postsEntity.message;\n```\n\nコンポーネント側では下記のように利用できます。\nまたuseSelectorやuseDispatchについても下記のように型を扱える形で利用が推奨されています。\n\n```typescript:src/app/hooks.ts（reduxテンプレート）\nimport { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\nimport type { RootState, AppDispatch } from './store';\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n```\n\nコンポーネント側ではusuSelectorからAdapterに対して下記メソッドでデータを取得することができます。\n\n- selectIds idの一覧を配列で取得\n- selectEntities entitiesオブジェクトを取得\n- selectAll 全件の配列を取得\n- selectTotal 件数を取得\n- selectById 該当するidに紐づくデータを取得\n\nselectAllとselectByIdが一番利用することになるかと思います。\n\n```typescript:コンポーネント側\n// 全件を取得\nconst posts = useAppSelector(selectPosts.selectAll);\n\n// idを指定して取得\nconst post = useAppSelector((state) => selectPosts.selectById(state, postId));\n```\n\nこのような形でエンティティ化されたものから、意識せずに通常の配列の形に変換されて変数へ格納することが可能です。\nまたcreateAsyncThunkでの実行結果は下記のようにコンポーネント上でも参照することができます。\n\n```typescript:コンポーネント側\nconst resultAction = await dispatch(fetchEntityPosts());\n// 失敗時であればrejected、\n// 成功時、ローディング時はそれぞれfullfilled、pendingとmatchさせることで判別が可能\nif (fetchEntityPosts.rejected.match(resultAction)) {\n  alert('データの取得に失敗しました。');\n}      \n```\n\n## さいごに\nReactを勉強し始めた時点ですでにToolkitも1.4になっていたので最初からToolkitを利用していましたが、Reduxについては公式サイトのドキュメントを読み直すたびに新しい気付きがあります。とりあえず、しばらくはcreateAsyncThunkとcreateEntityAdapter推しでいこうと思います。",
      "image": "/assets/images/dummy01.jpeg",
      "like": 0,
      "publish": false
    }
  ]
}